===================================================================================
クラスローダーとJ2EEパッケージング戦略を理解する
===================================================================================

.. contents:: 目次
   :depth: 2


| 下記サイトを参照して学習を実施。
| http://www.ibm.com/developerworks/jp/websphere/library/java/j2ee_classloader/
|

第1回 「クラスローダーを理解する - クラスはどこからやってきた？」
===================================================================================

|
| WebSphere Application Server内でのクラスローダー構成

.. image:: ./img/02_1_1.gif

|
| クラスローダーを理解するうえで最も重要な概念は、「デリゲーションモデル」です。クラスローダーは、必要に応じて親クラスローダーにクラスのロードをお願い、つまりお任せ、委譲（デリゲート）するのです。
|

.. warning::

   デリゲーションモデルで重要なことは、決して子供にお願いすることはないということです。上にたどることはあっても、下を探すことはありません。

|
|

第2回「クラスローダーを理解する - シングルトンがシングルトンでなくなる日」
===================================================================================

|
| クラスローダーのうち、アプリケーション・クラスローダーとWARクラスローダーについては、デリゲーション・モードをカスタマイズすることが可能です。
| デリゲーション・モードの設定は2種類です。
| 「PARENT FIRST（親が最初）」と「PARENT LAST（親が最後）」です。
|

- 「PARENT FIRST（親が最初）」（デフォルト値）の場合 自クラスローダーのローカル・クラスパスを探す前に、最初に親クラスローダーにデリゲートします。親で見つからなかったときにはじめて、自分のローカル・クラスパスを探しに行きます。
- 「PARENT LAST（親が最後）」の場合 自クラスローダーのローカル・クラスパスを最初に探します。見つからなかったときにはじめて、親クラスローダーにデリゲートします。

|
| デリゲーション・モードの設定によってクラスを探す順番が変わってきます。WARクラスローダーがあるクラスをロードする場合、表1に示す順番で各クラスローダーがクラスを探すことになります。
|

.. image:: ./img/02_1_1.gif

|

.. image:: ./img/02_2_8.gif

|
| 例えば、デフォルト値である「（A）APP-FIRST、WAR-FIRST」、すなわち、アプリケーション・クラスローダー、WARクラスローダーどちらも「PARENT FIRST」の場合は、探す順番はクラスローダー・ツリーの上から下へ単純に降りてくることになります。
|
|

.. note::

   Java基本クラスローダーが担当するコアクラス（java.lang.*など）に関しては、たとえ「PARENT LAST」にしても、「上書き」できません。これはJavaのセキュリティー・モデルで禁止されています。これを許すと、攻撃者に内部攻撃の機会を与えてしまうことになります。例えば、java.lang.String等を勝手に書き換えられたら、java.lang.Stringの不変性に依存しているクラスなどは、その前提が破壊されていまうことになり、重大なセキュリティー・リスクを背負うことになります。

|
|

第3回「J2EEパッケージング戦略を理解する-恐怖のドッペルゲンガー」
===================================================================================

|
| J2EEパッケージング戦略の基本方針は、J2EE仕様に準拠した「どんなアプリケーション・サーバーでも通用するポータブルなEAR」を作成すること。
| そのためのルール

1. EARは独立・自己完結したアプリケーションのパッケージング単位です。EARひとつを渡せば全て済むというのが、正しいEARの姿です。EAR以外のライブラリーが別途必要だったり、アプリケーション・サーバー特有のクラスパスの修正を要求したりするようなEARは、「不完全なEAR」とみなして毛嫌いしましょう。
2. クラスローダー・デリゲーションモードの設定は、アプリケーション・クラスローダー、各WARクラスローダー、共に「PARENT LAST（親が最後）」に設定します。
3. クラスローダー・ポリシー（アイソレーション・モード）の設定は、デフォルト設定をそのまま使用します。アプリケーションごとにアプリケーション・クラスローダーが1つ、さらに下位クラスローダーとして、WARごとに専用のWARクラスローダーが1つずつ割り当てられる設定です。決して「パッケージングについてあまり考えたくない」という理由だけで、後先のことを考えずに「単数（シングル）」や「アプリケーション」等に変更しないでください。「ダークサイド」に落ちてはいけません。

|
| それによるメリット

1. 自己完結EARのためサーバー環境からの影響を受けにくい
2. ライブラリーの可視範囲を最小限におさえることができるためクラス汚染を防げる

|
|

J2EEパッケージング戦略-モデル1
--------------------------------------------------

| 一例です。
|
| **図1 モジュール・ライブラリー依存関係**

.. image:: ./img/02_3_1.gif

|
| WARひとつの場合と同様に、各WAR内部に使用するライブラリーを全て入れておきます。さらに、EARの直下にも使用ライブラリーを配置しています。

::

  luv-app.ear
    - META-INF/application.xml
    - ejb1.jar
    - ejb2.jar
    - utility.jar
    - commons-xxx.jar
    - luv1.war
        - WEB-INF/lib
          - utility.jar
          - commons-xxx.jar
          - struts.jar
    - luv2.war
        - WEB-INF/lib
          - utility.jar
          - commons-xxx.jar
          - struts.jar
    - luv3.war
        - WEB-INF/lib
          - commons-xxx.jar
          - struts.jar
          - web-util.jar

|
| **図2 クラスローダーの観点から見た場合 - Missing library？**

.. image:: ./img/02_3_2.gif

|
| 図2は、クラスローダーの観点から見た場合、各モジュール・ライブラリーがどのように配置されるかを示したものです。
| utility.jar等に依存しているEJBモジュールは、このままでは正常に動作しないことがわかるでしょう。EJBモジュールはutility.jarを発見できません。
| 下位クラスローダーである各WARクラスローダー内は、クラス検索の対象にならないからです。
|
|
| そこで、パッケージングを行う際は、使用する依存ライブラリーをJ2EEコンテナに教えてあげる必要があります。
| 今回の例では、EJBモジュール・ejb1.jarは、utility.jar等に依存しています。そこで、このEJBモジュール内部の、マニフェスト・ファイル「META-INF/MANIFEST.MF」に使用するライブラリーを宣言しておきます。
|
| **ejb1.jar内のMETA-INF/MANIFEST.MFの内容**

::

  Manifest-Version: 1.0
  Class-Path: utility.jar
   commons-xxx.jar
   commons-yyy.jar
   commons-zzz.jar

|
| マニフェスト・ファイルの「Class-Path」エントリーがライブラリー発見メカニズムです。
| J2EEコンテナは、J2EEモジュール、すなわちWAR、ejb-jar内のマニフェスト・ファイルにClass-Pathエントリーがあった場合、そこに宣言されているライブラリーを、アプリケーション・クラスローダー配下に配置します。
| Class-Pathエントリーに記述するパスは、EARのトップからの相対位置で指定します。
| EAR内に同梱され、J2EEモジュールから使用されるライブラリーのことを、J2EE仕様では「Bundled Optional Package」と呼んでいます。
|
| **図3 クラスローダーの観点から見た場合 - Bundled Optional Packageの可視化**

.. image:: ./img/02_3_3.gif

|
|

.. warning::

   | WARに含まれているクラスを、別のWARやJARの中から使用しようとしないでください。このように、luv2.warへの参照を明記しても、luv2.war内のクラスが見えるようにはなりません。WARはあくまで、Web「アプリケーション」であって、「ライブラリー」ではないのです。他から使用するようものではありません。
   | そもそも、WARはライブラリー「Jar」ではないのです。確かにWARの物理的なファイル・フォーマットは「Jar」ですが、論理的なパッケージング構造は「Jar」ではありません。「Jar」がライブラリーとして正しく機能するためには、Javaのパッケージ階層構造がそのまま「Jar」内部のディレクトリー構造と一致する必要があります。そういう意味では、EJBモジュールは、「Jar」です。Javaのパッケージ階層構造がそのままJarとしてパッケージングされているからです。
   | 「あるWARに含まれているクラスを、別のWARでも使用したくなった」[注]というのはよいメッセージです。そのクラスが「ある1つのWebアプリケーション特有」ではないということを教えてくれています。そのクラスは、別途ユーティリティーJarとしてライブラリー化した方がよいでしょう。

|
|

J2EEパッケージング戦略-モデル2
--------------------------------------------------

|

::

  luv-app.ear
    - META-INF/application.xml
    - ejb1.jar
    - ejb2.jar
    - utility.jar
    - commons-xxx.jar
    - struts.jar
    - luv1.war
    - luv2.war
    - luv3.war
        - WEB-INF/lib
          - web-util.jar

|
|

.. image:: ./img/02_3_4.gif

|

.. note::

   マニフェスト・ファイルの修正を忘れないでください。


|
|

時間と空間 - トレードオフ
--------------------------------------------------

|
| モデル1では、各WARの独立性が高まります。
| あるWAR内でのライブラリーの変更は、他のWARへ影響を与えません。
|
| モデル2では、ライブラリーは一箇所に置かれるため、ライブラリーの管理は容易になります。
| また、ランタイム時、若干ではありますがリソースの節約にもつながります。
| その反面、EAR内の全てのWARにそのライブラリーは公開されるというリスクを背負うことにもなります。
|
| モデル1、モデル2のどちらがよいかは、むしろ、ライブラリーごとに決定するべき問題といえる。
|
|
|

第4回「ディフェンシブ・パッケージング」
===================================================================================

|
| commons-loggingについての実際の例にて説明
| http://www.ibm.com/developerworks/jp/websphere/library/java/j2ee_classloader/4.html
|
|

第5回「スレッド・コンテキストを理解する」
===================================================================================

|
| プロパティの読み込みを行うユーティリティクラスPropertiesUtilも、ユーティリティJAR(utility.jar)の中にいれて、EAR内にひとつだけ置くことにしました。

.. image:: ./img/02_5_2.gif

|
| 今回（図2）のケースでは、PropertiesUtilクラスは、アプリケーションクラスローダー配下にあります。
| そのため、この箇所で取得・使用されるクラスローダーは、クラス「Class<PropertiesUtil>」をロードしたクラスローダー、すわわちアプリケーションクラスローダーです。
| 親クラスローダーであるアプリケーションクラスローダーは、子クラスローダー配下に存在するプロパティファイルを見つけることはできません。
|
| 今回のようなケース、すなわち

- 共通ユーティリティクラス、いわゆる「ライブラリ」は親クラスローダー配下に存在
- ライブラリを利用するクライアント、すなわちアプリケーションのクラスは子クラスローダー配下に存在

| というのは、Java EEの世界に限った話ではなく、Javaでは非常によくある形態です。
| このような場合に、ライブラリ側から、クライアント側であるアプリケーション内のリソースを取得するにはどうすればよいでしょうか？
|

方法1: クラス（クラス・ローダー）を明示的に渡す
------------------------------------------------------

|
| 「ライブラリ側が、クライアント側のクラスローダーを、なんらかの方法で取得できればよい」のですから、まず最初に思いつく方法として、「リソースの読み込みに使用するクラスローダーを、ライブラリ側がクライアントから明示的に受け取る」ことが考えられます。
| この場合は、クライアント側はリスト7のようになります。クラスローダーを直接受け渡してもよいですが、ここではクライアント側の自クラスをライブラリ側に渡すことにします。
|
| **リスト7: クライアント側 - クラスを明示的に渡す**

::

  public class MyPojo {
    PropertiesUtil propUtils = ...; // get instance

    void init() {
        Properties props = propUtils.getProperties("module.properties", getClass());
        ...
    }

|
| ライブラリ側では、渡されたクラスからクラスローダーを取得、リソースの読み込みに使用します（リスト8）。
|
| **リスト8: ライブラリ側 - 渡されたクラスからクラスローダーを取得して使用**

::

   public class PropertiesUtil {

     public void Properties getProperties(String name, Class<?> clazz) {
         ClassLoader cl = clazz.getClassLoader();
         InputStream is = cl.getResourceAsStream(name);
         ...
     }


|
|

方法2: コンテキスト・クラスローダーを用いる
------------------------------------------------------

|
| 鍵となるのは、「スレッド・コンテキスト」です。リスト9をご覧ください。
|
| **リスト9: コンテキスト・クラスローダーを用いる**

::

   public class PropertiesUtil {

     public void Properties getProperties(String name) {
         ClassLoader cl = Thread.currentThread().getContextClassLoader();
         InputStream is = cl.getResourceAsStream(name);
         ...
     }

|
| 現在のスレッド（Thread.currentThread()）にセットされている「コンテキスト・クラスローダー」を取得しています。
| 方法1のように明示的にクラスやクラスローダーを受け取ることなく、「現在の呼び出し側」のクラスローダーを取得することが可能です。
|
| Java EEの世界ではどのようにコンテキスト・クラスローダーが決定されるのでしょうか？
|
| 実例で理解するため、図3に示すEARを取り上げます。このEARを用いた場合、PropertyUtilsまでの呼び出しシーケンスと、その結果、クラスPropertyUtils内で取得できるコンテキスト・クラスローダーの対応を表1に示します。
|
|

.. image:: ./img/02_5_3.gif

|
|

.. warning::

  スレッド・コンテキストが変化するのは、サーブレットやEJB等のJava EEのコンポーネントを「正式に」呼び出した時、すなわち、HTTPリクエストを受けてサーブレットの処理が始まったときや、EJBコールを行ったときになります。ケース5のように、EJB JAR内の含まれるクラス「MyPojoInEJBJar」を単に経由するだけでは、スレッド・コンテキストが変わることはありません。この場合は、コンテキスト・クラスローダーはWARクラスローダーのまま変化しないことにご注意ください。

