========================================
J2EEパターン -明暗を分ける設計の戦略-(書籍)
========================================

.. contents:: 目次
   :depth: 3


J2EEプラットフォーム概要
==============================================

J2SEに含まれるAPI
------------------------------
=================================== ===============================
機能                                パッケージ名
=================================== ===============================
グラフィカルユーザインターフェース  java.awt.* , javax.swing.*
----------------------------------- -------------------------------
データベースアクセス                java.sql.*
----------------------------------- -------------------------------
ディレクトリアクセス                javax.naming.*
----------------------------------- -------------------------------
CORBA                               javax.rmi.CORBA.*
----------------------------------- -------------------------------
セキュリティ                        java.security
----------------------------------- -------------------------------
入出力                              java.io.*
=================================== ===============================



J2EEアプリケーションのコンポーネントおよびコンテナ
------------------------------------------------------------

|
| **Jabaアプリケーションコンポーネント**
| アプリケーションコンテナ内で動く独立したJavaプログラム
|
| **アプレットコンポーネント**
| 合おうレットコンテナ内で動くJavaアプレット
|
| **サーブレットおよびJSP**
| Webコンテナ内で動くWeb層のコンポーネント。
| コンテンツの動的な準備や処理、表示形式に合わせた書式の整形メカニズムが提供される。
|
| **EJBコンポーネント(エンタープライズBean)**
| EJBコンテナ内で実行される粗粒度のビジネスコンポーネント。
| セッションBeanとエンティティBeanがある。
|
| ★セッションBean
| 処理やワークフローを扱うのに適しており、ステートフルとステートレスの2種類がある。
| ステートフルセッションBean：メソッド呼び出しをまたがってクライアントの状態を保持する
| ステートレスセッションBean：クライアントが呼び出すメソッドの間で状態を保持する必要がない場合に使われる(パフォーマンス上は有利)
|
| ★エンティティBean
| ビジネスコンポーネントを永続化し、複数のユーザで共有する必要があるばあイン使用される。
| 永続性を管理する方法にはBean管理による永続性(BMP)とコンテナ管理による永続性(CMP)の2種類がある。
| BMP：Bean内の状態を永続化するメカニズムの全てをBean開発者が実装する場合に使う。
| CMP：Beanの永続化メカニズムを開発者が実装しない場合に使う。開発者はBean属性と永続化ストレージ間の必要なマッピングを指定し、その後の仕事はコンテナに任せる。
|
|

プレゼンテーション層における設計上の考慮すべき事項と悪い方法
==============================================

クライアント上でのセッション状態の保持
------------------------------------------------------------

|
| クライアント上にセッション状態を保持するには、HTMLページ内にセッション状態を直列化してう\目込む必要がある。
|
| クライアント上にセッション状態を保持することの利点

- 比較的実装しやすい
- 少量の状態を保存するのに向いている
- 物理的にまたがった負荷分散を実装するときに、複数のサーバ上に状態の複製を作らなくても良い

|
|方法

- HTMLのhiddenフィールド
- HTTPクッキー
- 各ページで参照するURIにセッション状態を直接埋め込む

|
| **HTMLのhiddenフィールド**
| ・比較的実装が簡単
| ・保存する量が多い場合はパフォーマンス悪い(リクエストやレスポンスごとにネットワーク上で状態をやりとりするため)
| ・保持される状態が文字列に限られる
| ・暗号化しなければ、HTMLソース内にプレーンテキストとして表示される
|
| **HTMLクッキー**
| ・実装しやすい
| ・保存する状態の量が多い場合はパフォーマンスに影響(リクエストやレスポンスごとにネットワーク上で状態をやりとりするため)
| ・サイズや型の制限有り(クッキーヘッダのサイズに制限有り。そのためデータ量が限られる)
| ・保持される状態は文字列化された値に限られる
|
|

.. note::

   クライアント上でセッションを保持する場合は、セキュリティの問題を考慮しなければならない。データをクライアントに見せたくない場合は、何らかの暗号化を取り入れてデータを守る必要がある。

|
|

プレゼンテーション層でのセッション状態の保持
------------------------------------------------------------

|
| セッション状態をサーバで保持する場合、セッション状態はセッションIDを使用して取り出され、
| たいてい次のいずれかが起きるまで保持される。
|

- あらかじめ決めたタイムアウト時間が経過する
- セッションが手動で無効にされる
- セッションから状態が削除される

|
| **セッションをサーバに保持する利点**

- 保存するデータのサイズや型が自由である
- セッション状態をさらさないため、セキュリティの問題が発生しない
- パフォーマンスに影響しない

|
|

クライアントアクセスの制御
------------------------------------------------------------

　　ビューの保護
------------------------------------------------------------

| ある特定のユーザからアクセスできないようにビューを制限する方法
|
| **戦略**

1. コントローラやビューの処理時にアクセスを不可能にするロジックを追加する
2. あるリソースに対しては、別のアプリケーションリソースからの内部呼び出しによってしかアクセスできないように実行システムを設定する

|
| 2に関して、リソースに対するアクセスはプレゼンテーション層の別のアプリケーションリソース(コントローラとなるサーブレットなど)を経由して行う必要がある。
| 制限されたリソースにはブラウザからの直接呼出しによってアクセスすることはできない。
|
| 1に関して、実現方法は2通りある。

- コントローラをアクセス制御の入り口として使う(第五章で説明)
- アクセス制御機能を直接ビューに埋め込む

|
| **ビューに保護既往を埋め込む方法**

- リソース全体へのアクセスをブロックする方法
- リソースの一部へのアクセスをブロックする方法

|
|
| **ビューごとに全体を保護**

.. warning::

   この種の保護はロジックがコード中に散在することが無いよう、共通のコントローラにカプセル化するべき。そのため、この戦略が適しているのは、ごく一部のページだけに保護が必要な場合に限られる。

|
| 例)
| サイト上のページを見るユーザにログインさせる必要が有る場合

::

  <%@ tagline uri="/WEB-INF/corej2eetaglibrary.tld" prefix="corePatterns">

  <corePatterns:guard />
  <HTML>
  .
  .
  </HTML>

|
|
| **ビューの一部を保護**
|
| ※ユーザのロールに基づきビューの一部の表示を制限

::

  <%@ tagline uri="/WEB-INF/corej2eetaglibrary.tld" prefix="corePatterns">

  <HTML>
  .
  <corePatterns:guard role="manager">
  <b>This should be seen only by managers!</b>
  <corePatterns:guard />
  .
  </HTML>


　　設定によって保護を行う場合
------------------------------------------------------------

| プレゼンテーションエンジンの設定により、RequestDispatcherを使ったコントローラサーブレットのようなほかの内部リソース経由でしたアクセスを許可しないようにする方法がある。
| Webkonntena に組み込まれたセキュリティメカニズムを利用する方法もある。この場合、セキュリティ制約はweb.xmlというデプロイ記述に定義する。
|
| **標準のセキュリティ制約でリソースを保護**
| web.xmlにセキュリティ制約を設定することで、ファイルへのアクセス制御を追加することが出来る
|
| **単純で一般的な設定でリソースを保護**
| WEB-INFフォルダ配下にJSP資材を格納することでリソースにクライアントが直接アクセスすることを防ぐことが出来る！
|
|

　　バリデーション
------------------------------------------------------------

|
| バリデーションは、クライアント側(JavaScriptを使用した精査)でのバリデーションのみでは不十分である。
| ※HTMLを直接編集することにより、精査を無効にすることが出来るため
|
| サーバサイドでは精査のコードが混在することを防ぐため、
| バリデーションロジックをコンポー年tやサブシステムにカプセル化するのが一般的。
|

ヘルパークラスのプロパティ　～統合性および一貫性～
------------------------------------------------------------

| JavaBeanのヘルパークラスは、クライアントリクエストと一緒に渡されるときに、主として中間の状態を保持するために使われる。
| JSPのランタイムエンジンはサーブレットのリクエストオブジェクトからこれらのJavaBeansヘルパーのプロパティへ、
| パラメータの値を自動的にコピーするメカニズムを提供する。
|
| このメカニズムを使用するときは、下記に注意すること。
| サーバにパラメータが送られない限り、<jsp:setProperty>の機能を使ったときには対応するBeanプロパティは変更されないままになる。
| そのため、開発者が明示的に値を変更しなければ、アプリケーション中のデータが矛盾を起こしたり不正確になったりする危険がある。
| この問題に対する設計上の簡単な解決策は、リクエスト間でJabaBean内のすべての状態をリセットすることである。
|
|

プレゼンテーション層における悪い方法
------------------------------------------------------------

　　複数のビューに制御コードが含まれている
------------------------------------------------------------

| **問題概要**
| JSPビューの先頭にカスタムタグのヘルパークラスが含まれていて、アクセス制御やその他のチェックを行うことがあります。
| 多数のビューに同じようなヘルパーの記述が含まれていると、複数の箇所を変更しなければならずコードの保守が困難になります。
|
| **解決方法**

- コントローラと、それに連携するコマンドヘルパークラスを導入して制御コードを一環所に纏める
- JSPビューの一部だけを特定のユーザから見えないようにするために、複数の箇所に同じような制御コードを含める必要がある場合は、その作業を再利用可能なヘルパークラスに委譲する

|
|

　　プレゼンテーション層のデータ構造がビジネス層に公開されている
------------------------------------------------------------

|
| **問題概要**
| HTTpServletRequesterといったプレゼンテーション層のデータ構造は、プレゼンテーション層の内部でしか使えないようにすべき。
| これらの詳細をビジネス層や他のそうと共有すると、そうの間の結合度が高くなり、利用できるサービスの再利用性が大きく低下する。
| ビジネスサービスのメソッドの子具に茶がHttpServletRequest型のパラメータを受け取るようになっている場合、
| このサービスのクライアントは自分のリクエストをHttpServletRequestオブジェクトにラップしなければなりません。
| 更にビジネス層のサービスはプレゼンテーションオス固有のデータ構造とどのように相互作用するかを理解しなければならず、
| ビジネス層のコードがより複雑になり、プレゼンテーション層とビジネス層の結合度が高くなる。
|
| **解決方法**

- プレゼンテーション層固有のデータ構造をビジネス層と共有するのではなく、その状態をより一般的なデータ構造にコピーし、それを共有する。
- プレゼンテーション層固有のデータ構造から関連する状態を取り出して、個々のパラメータだけ共有する。

|
|

　　プレゼンテーション層のデータ構造がドメインオブジェクトに公開されている
------------------------------------------------------------

|
| **問題概要**
| HttpServletRequestといったリエスト処理用のデータ構造をドメインオブジェクトと共有すると、あぷ襟ケーションにおけるこれら全く異なる二つの機能の結合度が高くなってしまう。
| ドメインオブジェクトは再利用可能なコンポーネントであるべきで、その実装がプロトコルやそうに固有な詳細データに依存してしまうと、再利用の可能性は低くなる。
| また、結合度の高いアプリケーションの保守やデバックは困難である。
|
| **解決方法**

- HttpServletRequestオブジェクトをパラメータとして渡すのではなく、リクエストオブジェクトから状態を一般的名データ構造にコピーし、そのオブジェクトをドメインオブジェクトとして共有する
- HttpServletRequestオブジェクトから関連する状態を取り出して、それぞれの状態を個々のパラメータとしてドメインオブジェクトに渡す。

|

.. note::

   ドメインオブジェクトとは、実世界の中で問題領域を構成しているアプリケーション固有のオブジェクトのこと。例えば、ある書籍販売アプリケーションにおける書籍オブジェクトが、ドメインオブジェクトに相当する。

|
|

　　フォームの重複送信を放置している
------------------------------------------------------------

|
| **問題概要**
| クライアントか環境としてブラウザを使用する場合、アプリケーションがクライアント側の操作を制御する方法が』無く、
| 二重リクエストを送信してしまう可能性がある。
|
| **解決方法**

- クライアントからのリクエストフローを監視し、制御する

|
|

　　クライアントが機密リソースに直接アクセスできる
------------------------------------------------------------

|
| **問題概要**
| 情報にクライアントが直接アクセスする必要が無いのであれば、その情報は保護されるべき。
| 設定ファイルやプロパティファイル、JSP、クラスファイルが適切に保護されてなければ、クライアントは偶然or悪意をもって機密情報を取り出してしまう可能性がある。
|
| **解決方法**

- 機密リソースを保護し、クライアントが直接アクセスできないようにする

|
|

　　<jsp:setProperty>でBeanのプロパティがリセットされると想定している
------------------------------------------------------------

|
| **問題概要**
| <jsp:setProperty>は、リクエストパラメータをJavaBeanヘルパーの同じ名前のプロパティにコピーする。
| しかし、空の値をもったパラメータは無視されるが、開発者の多くは対応するJavaBeanのプロパティにnullや空の文字列が代入されると誤解している。
|
| **解決方法**

- Beansを使用する前にそのプロパティを初期化する

|
|
|

　　コントローラーが肥大化する
------------------------------------------------------------

|
| **問題概要**
| ビューとなる複数のJSPに繰り返し埋め込まれるコードは、リファクタリングの結果、コントローラーに移されることが多い。
| コントローラに多くのコードを追加しすぎると、コントローラは重くなり、保守やテスト、デバックが厄介になる。
|
| **解決方法**

- コマンドオブジェクトをj使用して制御コードをカプセル化し、コントローラはそこに処理を委譲する。

|
|

ビジネス層における設計上の考慮すべき事項と悪い方法
==============================================

セッションBeanの使用
------------------------------------------------------------

|
| セッションBeanとは以下の仕様をもった分散ビジネスコンポーネントである。

- セッションBeanは１つのクライアントあるいはユーザ専用として使われる。
- セッションBeanはクライアントセッションが持続しているあいだだけ存続する。
- セッションBeanはコンテナがクラッシュしたときには残らない。
- セッションBeanは永続オブジェクトではない。
- セッションBeanはタイムアウトを起こすことが出来る。
- セッションBeanはトランザクションを意識する。
- セッションBeanを使って、クライアントとビジネス層のコンポーネントとの間に、ステートフルなあるいはステートレスの対話をモデル化できる。

|

セッションBean　―ステートフルとステートレス
------------------------------------------------------------

| EJBコンテナはエンタープライズBeanのライフサイクルとインスタンスを最適に管理するためにシステムのリソースを監視する責務を持ちます。
| コンテナは、エンタープライズBeanのプールを管理し、呼び出しやリソース消費を最適化するために
| エンタープライズBeanをメモリ領域に入れたり出したりする。(活性・非活性)
|

.. warning::

   対話型のビジネスプロセスでステートレスセッションBeanを使うと、メソッドの呼び出しのたびに状態をクライアントからBeanに渡すか、ビジネス層で再構築するか、あるいは永続ストレージから取り出さなければならない。そのため、ネットワークトラフィックのオーバヘッドや再構築時間、アクセス時間などが原因で巣ケーらビリティが低下する可能性がある。

|
|

エンティティBean中のビジネスロジック
------------------------------------------------------------

|
| ビジネスロジック(プロセスやワークフロー、ビジネスルール、Дtあなどに関連する全てのロジック)をエンティティBeanに追加した場合におこりうることを調べるための質問の例

- ビジネスロジックによって、エンティティBean間の新たな関係gあ必要になるか
- エンティティBeanが、ユーザとの相互作用のワークフローを管理する責務をもつことになるか
- 他のビジネスコンポーネントが果たすべき責務を、エンティティBeanが引き受けることになるか
- Bean管理による永続化(BMP)ｗｐ使って実装するときに、Java Database Connectivity(JDBC)コードなどの、データアクセスに関するコードが、エンティティBeanに含まれることになるか

|
| これらの質問のいずれかにYesの答えが出たら、ビジネスロジックをエンティティBeanに持ち込むことで有害な影響がある可能性がある。
| エンティティBean』間の依存関係が出来るだけ設計に含まれないように確認しておくことは望ましい。
| そのような依存関係が有ると、アプリケーション全体のパフォーマンスを低下させる危険性のあるオーバヘッドが生じる。
|
| 一般的にエンティティBeanには、それ自体とその依存オブジェクトのデータを管理するための、内部で実行できるビジネスロジックだけを含むべき。
|
| エンティティBeanではなくセッションBeanに実装することを検討する必要がある。
|
|

ビジネス層およびインテグレーション層における悪い方法
------------------------------------------------------------

　　オブジェクトモデルを直接エンティティBeanモデルにマッピングする
------------------------------------------------------------

|
| **問題概要**
| EJBアプリケーションを設計するときに一般的に使われる方法の一つに、オブジェクトモデルを直接エンティティBeanにマッピングするという方法がとられる。
| つまり、オブジェクトモデル内の各クラスをエンティティBeanに変換する方法をとる。
| その結果、細粒度のエンティティBeanが数多く作られる。
| エンタープライズBeanの数が増えると、コンテナやネットワークのオーバーヘッドが増加する。
| また、このようなマッピングを行うと、オブジェクト間の関係はエンティティBean間の関係に変換される。
| エンティティBean間の関係を作ることは、パフォーマンスを悪化させる危険性があるため、極力避けるべき。
|
| **解決方法**
| オブジェクトモデル内のオブジェクトの依存関係を見分け、
| それを粗粒度のエンティティBeanとして設計する。
| これによって、各エンティティBeanはオブジェクトモデル内の関係するオブジェクトの集合体として構成されることになり、
| エンティティBeanの数が減る。
|
|

　　リレーショナルモデルを直接エンティティBeanモデルにマッピングする
------------------------------------------------------------

|
| **問題概要**
| EJBモデルを設計するときに、リレーショナルテーブルの各行をエンティティBeanにモデル化するのは悪い方法です。
| エンティティBeanは粗粒度のオブジェクトとして設計するのが最もいいが、このようなマッピングを行うと粗粒度のエンティティBeanが数多く作られてしまいスケーラビリティに悪影響を及ぼす。
| また、このようなマッピングでは、テーブル間の関係(主キーや外部キー)をエンティティBean間の関係として実装することにもなります。
|
| **解決方法**

- 既存のリレーショナルデータベースの設計をもとにEJBモデルを作るのではなく、オブジェクト指向のアプローチに従ってエンタープライズBeanを使ったアプリを設計する
- オブジェクトの依存関係を識別子、粗劉殿ビジネスオブジェクトを設計することで、エンティティBean巻の関係が発生しないようにする

|
|

　　各ユースケースをセッションBeanにマッピングする
------------------------------------------------------------

|
| **問題概要**
| 各ユースケースに対して個別のセッションBeanを実装するという人がいる。
| その結果、1種類の相互作用にのみ責任を持つ細粒度のコントローラが出来てしまう
| 欠点は、セッションBeanの数が増え、アプリケーションが非常に複雑になってしまうこと。
|
| **解決方法**
| Session Facadeパターンを使用して、関係の深い相互作用の集合を一つのセッションBeanに統合する。
| その結果、アプリケーションにおけるセッションBeanの数が減り、Session Facadeパターンを適用した場合の長所を利用することが出来る。
|
|

　　get/setメソッドでエンタープライズBeanの属性を全て公開する
------------------------------------------------------------

|
| **問題概要**
| get/setメソッドを使ってエンタープライズBeanの各属性を公開するのは、悪い方法です。
| この方法では、クライアントは細粒度のリモート呼び出しを数多く行うことになり、層をまたがったネットワーク上の通信量が大きく増加する可能性がある。
| すなわち、メソッド呼び出しはリモートで行われる可能性がある、パフォーマンスやスケーラビリティに影響するネットワークのオーバーヘッドが生じる。
|
| **解決方法**

- 属性ごとにget/setメソッドを用意するのではなく、Value Objectを使用してデータ全体をクライアントとやり取りする

|
|

　　サービスの検索をクライアントに埋め込む
------------------------------------------------------------

|
| **問題概要**
| クライアントやプレゼンテーション層のオブジェクトが、エンタープライズBeanを検索しなければならないことが頻繁にある。
| EJB環境では、コンテナがJNDIを使ってこのサービスを提供する。
| サービスの検索機能をクライアント自身にもたせると、アプリケーションコードにおける検索用コードの割合が急激に増える。
| そして、検索コードに何らかの変更を加えると、その変更はサービスを検索する全てのクライアントに伝播する。
| また、クライアントに検索コードを埋め込むと、背後にある複雑な実装をクライアントが知らなければならず、クライアントは検索コードに依存してしまうことになる。
|
| **解決方法**

- Service Locatorを使用して、検索メカニズムの実装をカプセル化する
- セッションBeanやエンティティBeanといったビジネス上のコンポーネントの実装を、Business Delegateを使用してカプセル化する。その結果、クライアントから直接エンタープライズBeanやサービスを扱う必要がなくなり、クライアントコードが単純になる。

|
|

　　エンティティBeanを読み出し専用オブジェクトをとして使う
------------------------------------------------------------

|
| **問題概要**
| エンティティBeanのメソッドはすべて、デプロイメント記述に指定されたトランザクション独立レベルにもとづくドランザクションセマンティクスに従う。
| エンティティBeanを読み出し専用オブジェクトとして使うと、単に多くのリソースを浪費し永続ストレージに対して不必要な更新トランザクションを行うことになる。
| これは、エンティティBeanのライフサイクルの中で、コンテナによってejbStore()メソッドが呼び出されるためである。
| コンテナはメソッド呼び出しの間にデータが変更されたかどうかを知ることが出来ないため、データが変更されたと仮定してejbStore()メソッドを呼び出す必要がある。
| つまり、コンテナは読み出し専用と読み書き可能なエンティティBeanを区別しない。
|
| **解決方法**

- Data Access Objectパターンを使い、データソースに対する全てのアクセスをカプセル化する。この結果、データアクセスコードを一箇所に集めるレイヤーができ、エンティティBeanのコードが単純になる。
- セッションBeanを使い、読み出し専用の機能へのアクセスを実装する。通常はDAOを使用したSession Facadeとして実装する。
- バリューオブジェクトの一覧を取得するために、Value List Handlerパターンを実装することも出来る。
- ビジネス層から複雑なデータモデルを取得するために、Value Object Assemblerパターンを実装することも出来る。

|
|

　　エンティティBeanを細粒度のオブジェクトとして使う
------------------------------------------------------------

|
| **問題概要**
| エンティティBeanはトランザクション機能をもつ粗粒度の永続ビジネスコンポーネントを表現するためのもの。
| エンティティBeanを使用して細粒度のオブジェクトを表現すると、ネットワーク通信やコンテナのオーバーヘッドが増加する。
| これは、アプリケーションのパフォーマンスやスケーラビリティに悪影響を及ぼす。
|

.. note::

   細粒殿オブジェクトとは、別のオブジェクトへの関連が無ければほとんど意味を成さないオブジェクトのこと。

|
| **解決方法**

- 既存のRDBMSスキーマにもとづいてエンタープライズBeanを設計する
- オブジェクトモデルを使ってエンタープライズBeanを設計する
- 粗粒度のエンティティBeanやセッションBeanを設計する。

|
|

　　エンティティBeanに依存するオブジェクトの構造全体を格納する
------------------------------------------------------------

|
| **問題概要**
| エンティティBean内部で依存オブジェクトの複雑なツリー構造が使われている場合、依存オブジェクトのツリー構造全体をロードしたり格納したりすると、パフォーマンスが急激に悪くなることがある。
|
| **解決方法**

- 以前下位の格納操作時以降に変更のあった依存オブジェクトを識別し、そのオブジェクトだけを永続ストレージに格納する。
- もっとも頻繁にアクセスされ、必要とされるデータだけをロードする戦略を実装する。それ以外の依存オブジェクトは必要に応じてロードする。

|
|

　　EJB関連の例外をEJBに関係のないクライアントに公開する
------------------------------------------------------------

|
| **問題概要**
| エンタープライズBeanはビジネスアプリケーションの例外をクライアントに送出できる。
| アプリケーションが例外を送出すると、コンテナは単純にその例外をクライアントに送出する。
| エンタープライズBeanやコンテナが、エンタープライズBeanに関連したシステム障害に遭遇したときにEJB関連の例外が起こり、アプリケーション開発者へ通知される可能性がある。
|
| **解決方法**
| Business Delegateを使用して、クライアントをビジネス層から切り離し、ビジネス層の実装をクライアントから隠蔽する。
| Business Delegateは、すべてのサービス例外を横取りし、必要に応じてアプリケーション例外を送出する。
|

　　エンティティBeanの検索メソッドを使って大規模な検索セットを返す
------------------------------------------------------------

|
| **問題概要**
| EJBの検索メソッドを使用してエンティティBeanの大規模な集合を検索する場合、リモートの参照先が返される。
| その結果、クライアントは各リモート参照のメソッドを呼び出してデータを取得しなければならない。
| この操作はリモート予備代sとなるため、集合内のエンティティBeanの参照ごとにリモート呼び出しを行おうとすると、大きなコストがかかりパフォーマンスに影響する。
|
| **解決方法**
| リモート参照ではなく、セッションBeanやDAOを使って、バリューオブジェクトのリストを取得するための問い合わせを実装する。
| また、EJBの検索メソッドではなくDAOを使って検索を行う。
|
|

　　クライアントがビジネスコンポーネントからデータを集めている
------------------------------------------------------------

|
| **問題概要**
| 一般的にクライアント(ビジネス層またはプレゼンテーション層)は、ビジネス層に含まれるアプリケーションのデータモデルを使用する。
| モデルはエンティティBean、セッションBean、またはビジネス層の任意のオブジェクトといったビジネスコンポーネントによって実装されているため、
| クライアントはさまざまなビジネスコンポーネントからデータを取得してモデルを構築しなければならない。
| こういったクライアントの作業により、クライアントからビジネス層への複数の呼び出しが原因となるネットワークのオーバヘッドが発生する。
| さらに、クライアントはアプリケーションモデルと密接に結合されている。
| 各種のクライアントが存在するアプリケーションでは、この結合度に関するもんぢあの影響は何倍にもなりかねない。
|
| **解決方法**
| クライアントがモデルを構築しなくてもいいようにする。必要なアプリケーションを構築する責任をもつビジネスコンポーネントを実装する。
|

　　長期にわたるトランザクションにエンタープライズBeanを使用する
------------------------------------------------------------

|
| **問題概要**
| エンタープライズBeanのメソッドがクライアントからのリクエストを処理するのにかなりの時間を必要とする場合、エンタープライズBeanが使用するメモリやスレッドといったコンテナリソースもブロックされてしまう。
| これにより、パフォーマンスに大きな影響がでて、システムリソースが枯渇する可能性がある。
|
| **解決方法**
| Java Messafe Service(JMS)APIにより、メッセージ指向ミドルウェア(MOM)を使って、長期にわたるドランザクションを実現するように非同期処理サービスを実装する。
|

　　ステートレスセッションBeanが呼び出しごとに対話状態を再構築する
------------------------------------------------------------

|
| **問題概要**
| セッションBeanで対話状態が必要であるにもかかわらず、ステートレスBeanを選択すると、メソッド呼び出しごとに対話状態を再構築する必要がある。
| 再構築によりパフォーマンスが大きく下がる可能性がある。
|
| **解決方法**
| ステートレスセッションBeanのモードを選択する前に、相互作用モデルを分析する。
| ステートフルセッションBeanでメソッドy歩日だしをまたがって対話状態を保持する必要性と、
| ステートレスセッションBeanで呼び出しごとに対話状態を再構築するコストを比較する。
|
|
