===================================
★WebSphere Application Server (WAS) 虎の巻
===================================

.. contents:: 目次
   :depth: 2


| 下記サイトを参照して学習を実施。
| http://www.ibm.com/developerworks/jp/websphere/library/was/toranomaki/
|

第1回「WebSphere Application Server (WAS) 概説」
==============================================

2. Java EE
--------------------------------------------------

| **Java EEのモデル**
| アプリケーション・サーバーが提供するのはWeb層とビジネス層の2層です。

.. image:: img/1_3.gif

| *※EIS：Enterprise Information System, 企業情報システム*
|

.. image:: img/1_4.gif

|

.. image:: img/1_5.gif

|
|
|

第2回「WebSphere Application Server（WAS）の複数台構成」
===================================================================

3.2. セッション・アフィニティー
--------------------------------------------------

| セッション・アフィニティーとは、セッションを使用したアプリケーションに対して、同一セッションIDを持つクライアントからの要求を毎回同じクラスター・メンバーに渡す方式です。
| クラスターではデフォルトで有効となっており、重み付きラウンドロビンやランダムよりも優先されます。

.. image:: img/2_8.gif

|

3.4. セッション・パーシスタンスとセッションのフェイルオーバー
--------------------------------------------------

| セッション・パーシスタンス機能は、セッション情報を外部のデータストア（DBまたは他のアプリケーション・サーバー）に格納することによって、複数のアプリケーション・サーバーでセッション情報を共有（セッションのクラスター化）します。
| セッションのクラスター化には以下の利点があります。
|

- セッションを使用するアプリケーションを、異なるノードにある複数のアプリケーション・サーバー上で実行することができ、効果的な負荷分散が実現できます。
- セッション途中で、このセッションの処理を行っていたアプリケーション・サーバー・プロセスがダウンした場合でも、セッションのフェイルオーバーが可能になります。

|
| 考慮しなければいけない点もあります。

- セッションを外部のデータストアに書き出すタイミングや、書き出すデータ量に応じてパフォーマンスに影響を与えるため、WASの管理者はこれらの設定について考慮する必要があります。
- アプリケーション開発者にとっても、セッション・データを外部のデータストアに書き出すため、セッション・オブジェクトはシリアライズ可能でなければならない、という制約があります。
- フェイルオーバーが発生した場合はセッションの状態が不整合になる可能性があることを考慮したアプリケーション・ロジックとする必要があります。


|

第3回「JDBCとデータベース接続」
===================================================================

|
| **JDBCプロバイダー、JDBCドライバー**

.. image:: img/3_2.gif

|

1.5.  データソース
--------------------------------------------------

| アプリケーション・サーバー上で動作させる場合、アプリケーション開発者の作成したJavaプログラムは、データソースを参照してデータベースにアクセスすることができます。
|
| アプリケーション・サーバー上にデータソースを定義するためには、まずJDBCプロバイダーを定義します。
| そのJDBCプロバイダーに対して、データソースを定義します。
| これらをアプリケーション・サーバーに設定することで、アプリケーションはデータソースを通じて接続を行うことが可能になります。
| 1つのデータソースに対し、1つのデータベースが結びつきますので、複数のデータベースにアクセスするアプリケーションでは複数のデータソースの設定が必要となります。
|

.. image:: img/3_4.gif

|


1.6. JNDI
--------------------------------------------------

| アプリケーションからデータベースへ接続を行う際、データベースへの接続情報をコーディングで直接指定することも可能です。
| しかし、この方法ではデータベースが変更になるたびに修正が必要となるため、可搬性に劣ります。
| 可搬性を上げるために用いられるのがJNDIと呼ばれる仕組みです。
|
| **デプロイメント記述子に参照を定義（リソース参照）**

.. image:: img/3_6.gif

|
|
| **複数データベースの切り替え**

.. image:: img/3_6.gif

|

2.データベース接続構成
--------------------------------------------------

|
| **2.1. アプリケーションの流れ**
|

1. JNDI名を引数とし、DataSourceオブジェクトを取得
2. DataSourceオブジェクトから接続オブジェクト（Connectionオブジェクト）を生成
3. 実行したいSQL文を引数にし、接続オブジェクトからStatementオブジェクトを生成
4. データベースに対しSQL文を実行し、結果(ResultSetオブジェクトなど)を取得
5. 各オブジェクトをクローズ

|
|

| **2.3. 接続プールで設定できるパラメーター**
|
| 接続プールで設定できるパラメーターには以下のようなものがあります。

- 最大接続数
- 最小接続数
- 接続タイムアウト
- リープ時間
- 未使用タイムアウト
- 経過タイムアウト

|
| **2.4.ステートメントのキャッシュ**
|
| **StatementとPreparedStatementを用いた際の処理**

.. image:: img/3_10.gif

|
|
| **2.5. 失効した接続オブジェクトへの対応**
|
| アプリケーション・サーバーとデータベースの間でのネットワーク障害、データベースの障害、データベースの再起動などが発生すると、
| 接続プールにプールされている接続オブジェクトは無効となり、その接続オブジェクトを用いたデータベース操作は行えなくなります。
| そのような失効した接続オブジェクトは接続プール内に残り続け、アプリケーションが接続プール内の接続オブジェクトを使用しようとした場合、StaleConnectionExceptionが発生します。
|
|

第4回「JMSとメッセージング・サービス接続」
===================================================================

|

1. メッセージング・サービス
-----------------------------------------

|
| Webシステムにおいてメッセージング・サービスと連携することで、Webアプリケーションの処理の一部を非同期に実行することが可能となります。
| 時間のかかる処理を非同期化することで、クライアントに対する見掛け上のレスポンスタイムや全体のスループットを向上させることができます。
|
| **Webシステムの特徴**

.. image:: img/4_01.gif

|
| **Webシステムにおける非同期処理**

.. image:: img/4_02.gif

|
| アプリケーションはクライアントからのリクエストを受け付け、処理をメッセージという形式でキュー（メッセージを保持する箱のようなもの）に送信します
| そしてクライアントには処理を受け付けたというレスポンスを返します。
| このように非同期処理によって、クライアント側の待ち時間を短縮することが可能になり、同時に時間のかかる処理は別のサブシステムに任せることができます。
|
|

2.メッセージング・サービスへのアクセス
-----------------------------------------

|
| **メッセージの送受信**

.. image:: img/4_03.gif

|
| JMSにおいては、JMS宛先があり、1つの送信アプリケーションが宛先に対して、メッセージをPUTします。
| もう一方の受信アプリケーションは、処理可能なタイミング、つまり非同期にそのメッセージを宛先からGETし、処理を実行します。
| 送信アプリケーションをメッセージ・プロデューサーと呼び、受信アプリケーションをメッセージ・コンシューマーと呼びます。
| 宛先の実体はメッセージング・サービス上に存在するキューやトピックとなります。キューやトピックはメッセージを保管するために使用されます。
|

.. image:: img/4_04.gif

|
|
| **JMS基本構成図**

.. image:: img/4_05.gif

|
| JMSクライアントであるWebアプリケーションはWAS上で定義されたJMS接続ファクトリーとJMS宛先を参照してメッセージング・サービスへアクセスすることができます。
|
| **JMS接続ファクトリーとJMS宛先**

.. image:: img/4_06.gif

|
|
| **JNDIによるリソース参照**

.. image:: img/4_07.gif

|
| JMS接続ファクトリーとJMS宛先のJNDIを参照してアクセスを行います。
| WAS側のJMS接続ファクトリーやJMS宛先にはJNDI名が定義されており、アプリケーション側でも仮のJNDI名が定義されています。
| データベースと同様にリソース参照の仕組みを利用して、アプリケーションのインストール時にアプリケーション側とWAS側のJNDIを紐付けることで、アプリケーションとメッセージング・サービスの接続が実現します。
|

3. メッセージング・サービス接続構成
-----------------------------------------

| JMS 1.1で定義されたJMS Common Interfaceを利用することで、PTPであるか、Pub/Subであるかに依存しないアプリケーションを開発できます。

1. JNDI名を指定して接続ファクトリー(ConnectionFactory)オブジェクトをlookup
2. JNDI名を指定して宛先(Destination)オブジェクトをlookup
3. 接続ファクトリー・オブジェクトから接続(Connection)オブジェクトを生成
4. 接続オブジェクトからSessionオブジェクトを生成
5. Sessionオブジェクトから宛先オブジェクトを指定してMessageProducer/MessageConsumerオブジェクトを生成
6. SessionオブジェクトからMessageオブジェクトを生成
7. MessageProducer/MessageConsumerオブジェクトにMessageオブジェクトを指定してメッセージを送受信
8. メッセージの送受信に成功したらSessionオブジェクトをコミット、失敗したらロールバック
9. 各オブジェクトをクローズ

|

.. image:: img/4_08.gif

|
|
| **接続プールおよびセッション・プール**

.. image:: img/4_09.gif

|
| アプリケーションの流れの中で、メッセージング・サービスへのアクセスには接続オブジェクトを利用することを説明しました。
| この接続オブジェクトの生成と消滅はメッセージング・サービスへの接続と切断を意味します。
| メッセージの送受信の度に接続を繰り返すことでアプリケーション・サーバーやメッセージング・サービスに余分な負荷がかかることになります。
| この接続処理のオーバーヘッドを緩和するために、一度作成した接続オブジェクトを接続プールに保持して、その後の接続要求に対して再利用することができます。
| JMSアプリケーションでは接続プールに加えてセッション・プールも利用され、Sessionオブジェクトを使いまわすことができます。
|
|
| 参考： `WAS および WebSphere MQ とともにJMS接続プールを使用する: （パート1） <http://www.ibm.com/developerworks/jp/websphere/library/was/was_jms/>`_
| 参考： `WAS および WebSphere MQ とともにJMS接続プールを使用する: （パート2） <http://www.ibm.com/developerworks/jp/websphere/library/was/was_jms/2.html>`_
|
|
|

4. MDB
-----------------------------------------

|
| Webシステムがメッセージング・サービスと連携する際には、前述のJMSに加えてMDBを利用した非同期処理が可能です。
|
| **MDBのしくみ**

.. image:: img/4_10.gif

|
| MDBでは、どのサーバーに接続して、どの宛先を監視するかといった設定をアクティベーション・スペック(Activation Specification：活動化仕様)に記述します。そしてEJBのデプロイメント時には、どのアクティベーション・スペックを利用するかを指定します。
|

.. image:: img/4_11.gif

|
|

第5回「リクエスト処理の流れ」
===================================================================

2. クライアント～Webサーバーにおける処理
-----------------------------------------

|
| **リクエストがWebサーバーへ送信されるまでの流れ**

.. image:: img/5_04.gif

|

4. WASにおける処理
-----------------------------------------

|
| **リソース定義**

.. image:: img/5_12.gif

|
|

第6回「SSL通信と証明書」
===================================================================

1. SSL通信とは
-----------------------------------------

|
| **通信を暗号化する**
|
| インターネット上を流れるデータを第三者に読み取られないようにするためには、通信を暗号化する必要があります。
|
| 暗号化とは、ある特定の情報変換のルールと鍵と呼ばれるデータを使って、元の文書やデータ（平文）を第三者からは意味のないデータに変えてしまうことをいいます。
| 逆に、暗号化したデータを可読なデータに変換することを復号と呼びます。
|
| データの送り手と受け手が事前に同じ鍵を保有し、暗号化と復号をその同じ鍵で行う方式を「共通鍵暗号化方式」と呼びます。
| 「共通鍵暗号方式」では、確実な共通鍵の受け渡し方法を考えなければなりません。もし、共通鍵が盗まれてしまったら第三者が簡単に暗号文を解読できてしまいます。また、通信相手ごとに鍵を用意する必要もあります。
|
| **共通鍵暗号方式**

.. image:: img/6_01.gif

|
|
|
| **公開鍵暗号方式**

.. image:: img/6_02.gif

|
| 公開鍵は広くインターネットで公開されることになりますが、その公開鍵は本当にWebサイトで発行されたものでしょうか？
| 悪意のある偽サイトが本物そっくりに作っている場合、本物の公開鍵であることを証明する仕組みが必要になります。それが次に説明する **電子証明書** です。
|
| 認証局 (CA: Certificate Authority) と呼ばれる信頼できる第三者機関が、Webサイトの所有者情報と公開鍵が正当なものであることを確認し、認証局の電子署名を付けて電子証明書として発行します。
| この電子署名にも公開鍵暗号方式と同様の仕組みが利用されます。
|
| Webサイト側では、発行された証明書をサーバーに用意しておき、Webサイトにアクセスしたユーザーに送信します。
| 電子証明書を受けとったユーザーは、認証局の公開鍵を利用して電子署名を検証し、発行先情報や公開鍵が正当なものであることを確認できるため、安全で確実に本物のWebサイトにアクセスすることができます。
|
| この仕組みを安全に利用するためには，信頼できる方法で認証局の公開鍵をユーザーに配布しておく必要があります。
| 一般的には，認証局の公開鍵はオペレーティング・システムやブラウザに組み込まれて配布されます。
| これらの製品については，信頼できる方法で入手した正規品を利用することが重要です。
|
|
|

SSL通信の流れ
-----------------------------------------

|
| 安全にデータの受け渡しを行うための暗号化通信であるSSL通信を説明します。SSLはトランスポート層とセッション層の間で安全性、機密性を提供するプロトコルです。
|
| **SSL通信の流れ**

.. image:: img/6_04.gif

|
|

2. Webシステムでの証明書の取り扱い
-----------------------------------------

|
| **セキュリティー要件の検討**
|
| Webシステムで考えなければならないセキュリティーのリスクの代表例
|

- サービス妨害（DoS攻撃など）
- セキュリティーホール悪用
- なりすまし
- 不正アクセス
- 盗聴
- 改ざん
- 不正コード埋め込み

|
| 悪意のあるDoS攻撃などのアクセスを防ぐには、ゾーニングやファイアウォールの設定などのハードニングを行います。
| なりすましを防ぐためには認証、不正アクセスを防ぐために認可などを検討します。
| 盗聴や改ざん、不正コード埋め込みといったネットワーク上のデータへのアクセスは証明書およびSSL通信を使って防ぎます。
| インターネットを流れる大切なデータは暗号化が必須となりますが、社内システム間の通信の場合、暗号化ではなく、そもそも社内システムに侵入されることを防ぐ必要があります。
|

.. image:: img/6_05.gif

|
| どこの通信をSSLにするかは安全性とパフォーマンスの兼ね合いになります。
| すべての通信をSSLにすると、安全性は高まりますが、すべてのコンポーネントで暗号化と復号の処理が発生しますのでパフォーマンスは悪くなります。
|
| 図5のようにWebサーバーより先の経路は、ゾーニングされており、通信が読み取られることがない場合には、HTTP通信を検討してよいでしょう。
| また、SSL通信を行う場合、通信を行う全てのコンポーネントに証明書を配置する必要があります。
| Webサーバーからアプリケーション・サーバーの通信とWASのコンポーネント間通信をHTTP通信にするとSSLの暗号化・復号の重い処理がなくなるため、最適なパフォーマンスが得られます。
|
|

第7回「WebSphere Application Server（WAS）のセッション管理」
===================================================================

3. セッション・パーシスタンス
-----------------------------------------

|
| 管理コンソールの分散環境設定にて設定する。
|
| セッション・パーシスタンスは、以下のような場合に使用します。

- あるクラスター・メンバーの障害時や停止時に、別のクラスター・メンバーにセッション情報をフェイルオーバーさせたい場合。
- クラスター構成でなくても、セッション情報が重要であり、サーバー障害時でもセッション情報を消失させたくない場合。
- メモリー上に保持するセッション数を制御したい場合。「メモリー内の最大セッション・カウント」を超えたセッションに対し、「オーバーフローの許可」をさせずに外部データストアに格納することで、メモリー上のセッション数を制御できます。

|
| 外部ストアに保存されるセッション・データは全てシリアライズ可能である必要があります。
| セッション・パーシスタンスを使用する場合は、アプリケーションの中で、HTTPセッションに格納するデータは全てjava.io.Serializableインターフェースを実装してください。
| ローカル・セッションの場合はこの処理は必須ではありません。
| しかしセッション・データがシリアライズ化されていないと、ローカル・セッションからセッション・パーシスタンスへ変更する際にアプリケーション・コードの変更が発生します。
|
|

4. セッション管理の考慮点
-----------------------------------------

|
| パフォーマンス上の一般的な考慮点
|
| **4.1. セッション・サイズ**
|
| セッション・オブジェクトのサイズが大きいと、それだけメモリーを消費します。
| セッションの使用メモリーが増えれば、アプリケーション実行に関わる他のタスクが使用するメモリー領域が減ってしまいます。
| これを防ぐには、いくつかの選択肢が考えられます。
|

- セッション・オブジェクトのサイズを削減する
- メモリー上のセッション数を削減する
- アプリケーション・サーバーを追加する
- 不要なセッションを適切なタイミングで無効化する
- 使用できるメモリーを増やす
- セッション・タイムアウトの時間を短くする

|
| セッション・オブジェクトのサイズは、セッション・パーシスタンス使用時には特に重要です。
| メモリー使用量への影響だけではなく、大きなデータをシリアライズして外部データストアに書きこむ処理にはオーバーヘッドがかかるからです。
| 一般的には、容易に取得できるデータや不要なデータはセッション・オブジェクトから削除して、セッションで管理するものは極力限定することが望まれます。
|
|
| **4.2. セッションの共有**
|
| サーブレット2.3では、セッション・オブジェクトにアクセスできるのは同一Webモジュールからと定義されています。従って、Webモジュールを跨ったセッションの共有はできません。
| WASでは、共有セッション・コンテキストという拡張機能を使用すると、アプリケーション間でセッション・データを共有することができます。この機能を使用するには、IBMApplicationSessionというWAS固有のAPIを使用する必要があります。
|
|
| **4.3. 障害復旧後のリクエスト・ディスパッチ動作の指定**
|
| サーバー障害が発生した場合、クライアントからのリクエストがフェイルオーバーして処理が継続します。
| サーバー障害復旧後には元のサーバーにフェイルバックします。
|
|
| **4.4. JSESSIONIDのフォーマット変更**
|
| 下記リンクの『4.4. JSESSIONIDのフォーマット変更』
| http://www.ibm.com/developerworks/jp/websphere/library/was/toranomaki/7.html
|
|

(運用管理編)：第1回「定常運用」
==============================================

|

.. image:: img/01_1.gif

| IHS、WASを構成するプロセスの起動は、管理する側から管理される側という順序で実施することが一般的です。
| 停止はその逆となり、管理される側から管理する側という順序で実施することが一般的です。
|

- IHS、WASの起動
   1. デプロイメント・マネージャー・プロセス
   2. ノード・エージェント・プロセス
   3. アプリケーション・サーバー・プロセス
   4. (IHS管理サーバー・プロセス)
   5. IHSプロセス

- IHS、WASの停止
   1. IHSプロセス
   2. (IHS管理サーバー・プロセス)
   3. アプリケーション・サーバー・プロセス
   4. ノード・エージェント・プロセス
   5. デプロイメント・マネージャー・プロセス


.. warning::

   ノード・エージェント・プロセスはアプリケーション・サーバー・プロセスより先に起動していなければならないという、製品仕様上の制約があります


|
| WAS・IHS起動停止コマンドに関しては、下記リンク参照。
| http://www.ibm.com/developerworks/jp/websphere/library/was/toranomaki_man/1.html#sec2
| ∟ 1-2 IHSプロセスの起動・停止
| ∟ 1-3 WASプロセスの起動・停止
|
|

2-4 WASログのメンテナンス
-----------------------------

- WASが出力する主なログ
   + JVMログ
   + プロセス・ログ
   + 診断トレース・ログ
   + IBM保守ログ(アクティビティー・ログ)
   + 初期障害データ・キャプチャー(FFDC)ログ

.. note::

   IBM保守ログ以外のログはJVMプロセス単位、つまり、デプロイメント・マネージャー、ノード・エージェント、アプリケーション・サーバーの単位で出力されます。


|
| **JVMログ**
|
| JVMログはSystem.outログとSystem.errログで構成されており、それぞれJVMのSystem.outストリームとSystem.errストリームが記録されます。
|
| <PROFILE_ ROOT>/logs/<サーバー名>/SystemOut.log (デフォルト)
| <PROFILE_ ROOT>/logs/<サーバー名>/SystemErr.log (デフォルト)
|
|
| **プロセス・ログ**
|
| プロセス・ログは標準出力ログと標準エラー出力ログで構成されており、それぞれプロセスの標準出力ストリームと標準エラー出力ストリームが記録されます。
| デフォルト設定では、正常時にログの出力はほとんどなく、プロセスの起動時に環境に関する情報が出力される程度です。
| ただし、冗長ガーベッジ・コレクション(GC)を有効化している場合は、GC毎の詳細情報(GCログ)がプロセス・ログに出力されます。具体的な出力先は、AIX、Linux、Windows環境では標準エラー出力ログとなり、Solaris、HP-UX環境では標準出力ログとなります。
|
| <PROFILE_ ROOT>/logs/<サーバー名>/native_stdout.log (デフォルト)
| <PROFILE_ ROOT>/logs/<サーバー名>/native_stderr.log (デフォルト)
|
|
| **診断トレース・ログ**
|
| 診断トレース・ログには、製品コンポーネントの内部処理に関する詳細情報が記録されます。
| デフォルト設定ではトレース・レベルが「*=info」に設定されており、基本的にログの出力はありません。
| 問題分析のためにより詳細なレベルに設定すると、短時間に大量の情報が出力される場合があります。
|
| <PROFILE_ ROOT>/logs/<server_name>/trace.log (デフォルト)
|
|
| **IBM保守ログ(アクティビティー・ログ)**
|
| IBM保守ログ(アクティビティー・ログ)には、JVMログに記録されるWAS関連メッセージと問題分析のための情報が記録されます。
| このログはノード上のJVMプロセス間で共用されており、1つのファイルに合わせて出力されます。
| バイナリー・フォーマットのファイルであるため、内容の参照には専用のツールを使用します。
| 主にIBMのサポート・センターや開発部門が問題分析を行う際に使用するログです。
|
| <PROFILE_ ROOT>/logs/activity.log (デフォルト)
|
|
| **初期障害データ・キャプチャー(FFDC)ログ**
|
| 初期障害データ・キャプチャー(FFDC)ログには、製品コンポーネントの内部処理で障害が発生した際に、関連するイベントやエラーの情報が自動収集され、記録されます。
| 主にIBMのサポート・センターや開発部門が問題分析を行う際に使用するログです。
|
| <PROFILE_ ROOT>/logs/ffdc/<サーバー名>_*.log
| <PROFILE_ ROOT>/logs/ffdc/<サーバー名>_*.txt
|


(運用管理編): 第2回「不定期運用」
==============================================

|
|

.. TODO::

   後で読む：http://www.ibm.com/developerworks/jp/websphere/library/was/toranomaki_man/2.html


|
|

.. TODO::

   後で読む：http://www.ibm.com/developerworks/jp/websphere/library/was/toranomaki_man/3.html

|
|
|